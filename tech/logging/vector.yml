data_dir: /var/lib/vector

sources:
  java_file:
    type: file
    include:
      - /var/log/java/ecom-backend.log
    ignore_older_secs: 0
    multiline:
      start_pattern: '^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}[+-]\d{2}:\d{2}\s'
      condition_pattern: '^(?:\s|at\s|Caused by:|Hibernate:)'
      mode: continue_through
      timeout_ms: 2000

transforms:
  enrich_env:
    type: remap
    inputs: [java_file]
    source: |
      .message = to_string!(.message)
      if !exists(.labels) { .labels = {} }
      .labels.env = "prod"
      .input = { "type": "file", "path": "/var/log/java/ecom-backend.log" }

  parse_spring:
    type: remap
    inputs: [enrich_env]
    source: |
      m, err = parse_regex(
        .message,
        r'^(?P<ts>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}[+-]\d{2}:\d{2})\s+(?P<level>[A-Z]+)\s+(?P<pid>\d+)\s+---\s+\[(?P<app>[^\]]+)\]\s+\[(?P<thr>[^\]]+)\]\s+(?P<logger>[^:]+?)\s*:\s*(?P<msg>.*)$'
      )

      if err == null {
        .timestamp = parse_timestamp!(m.ts, format: "%+")
        if !exists(.log) { .log = {} }
        .log.level = downcase!(m.level)
        if !exists(.process) { .process = {} }
        .process.pid = to_int!(m.pid)
        .labels.app = m.app
        if !exists(.thread) { .thread = {} }
        .thread.name = m.thr
        .logger = m.logger
        .message = m.msg

        if !exists(.event) { .event = {} }
        logger_s = to_string(m.logger)
        if starts_with(logger_s, "org.hibernate") {
          .event.dataset = "spring.hibernate"
        } else if starts_with(logger_s, "o.s") || starts_with(logger_s, "org.springframework") {
          .event.dataset = "spring.framework"
        } else if starts_with(logger_s, "o.a.") || starts_with(logger_s, "org.apache.") {
          .event.dataset = "spring.framework"  # Tomcat/Catalina/Apache
        } else {
          .event.dataset = "spring.app"
        }
      } else {
        msg_s = to_string!(.message)
        if starts_with(msg_s, "Hibernate: ") {
          if !exists(.event) { .event = {} }
          .event.dataset = "hibernate.sql"
          if !exists(.log) { .log = {} }
          .log.level = "info"
          if !exists(.sql) { .sql = {} }
          .sql.query = replace(msg_s, r'^Hibernate:\s*', "")
        } else {
          if !exists(.event) { .event = {} }
          .event.dataset = "spring.continuation"
        }
      }

      p, perr = parse_regex(.message, r'Tomcat initialized with port (?P<port>\d+)')
      if perr == null {
        if !exists(.http) { .http = {} }
        if !exists(.http.server) { .http.server = {} }
        .http.server.port = to_int!(p.port)
      }

  trace_and_context:
    type: remap
    inputs: [parse_spring]
    source: |
      t, terr = parse_regex(.message, r'(?:^|[\s,])trace_id=(?P<trace>[A-Za-z0-9\-_]+)')
      if !exists(.trace) { .trace = {} }
      if terr == null { .trace.id = t.trace } else { .trace.id = uuid_v4() }

      if !exists(.service) { .service = {} }
      app_s = "unknown-service"
      if exists(.labels) && exists(.labels.app) { app_s = to_string!(.labels.app) }
      lg = to_string!(.logger)
      if contains(lg, ".") {
        parts = split(lg, ".")
        if length(parts) > 2 {
          .service.name = parts[2]
        } else {
          .service.name = app_s
        }
      } else {
        .service.name = app_s
      }

  pii_mask:
    type: remap
    inputs: [trace_and_context]
    source: |
      if exists(.message) {
        .message = to_string!(.message)
        # Email → user***@domain
        .message = replace(.message, r'([A-Za-z0-9._%+\-])([A-Za-z0-9._%+\-]*?)@([A-Za-z0-9.\-]+\.[A-Za-z]{2,})', "$$1***@$$3")
        # Thẻ 13–19 digits → 1234********5678
        .message = replace(.message, r'\b(\d{4})\d{8,11}(\d{4})\b', "$$1********$$2")
        # Bearer token
        .message = replace(.message, r'(?i)(authorization:?\s*bearer\s+)[A-Za-z0-9\-\._]+', "$$1******")
        # apiKey/token/secret
        .message = replace(.message, r'(?i)(api[_\-]?key|token|secret)["\s=:]*[A-Za-z0-9\-\._]{6,}', "$$1=******")
      }
      if exists(.sql) && exists(.sql.query) {
        .sql.query = to_string!(.sql.query)
        .sql.query = replace(.sql.query, r'\b(\d{4})\d{8,11}(\d{4})\b', "$$1********$$2")
      }

  filter_debug_prod:
    type: filter
    inputs: [pii_mask]
    condition: '!(.labels.env == "prod" && .log.level == "debug")'

  route_by_dataset:
    type: route
    inputs: [filter_debug_prod]
    route:
      to_app: '.event.dataset == "spring.app"'
      to_framework: '.event.dataset == "spring.framework"'
      to_hibernate: '.event.dataset == "hibernate.sql" || .event.dataset == "spring.hibernate"'
      to_misc: '.event.dataset == "spring.continuation"'

sinks:
  es_app:
    type: elasticsearch
    inputs: [route_by_dataset.to_app]
    endpoints: ["https://192.168.157.10:9200"]
    auth:
      strategy: basic
      user: elastic
      password: "KHFDPeU6"
    tls:
      ca_file: "/etc/vector/certs/http_ca.crt"
    bulk:
      index: "ecommerce-backend-app-%Y-%m-%d"

  es_framework:
    type: elasticsearch
    inputs: [route_by_dataset.to_framework]
    endpoints: ["https://192.168.157.10:9200"]
    auth:
      strategy: basic
      user: elastic
      password: "KHFDPeU6"
    tls:
      ca_file: "/etc/vector/certs/http_ca.crt"
    bulk:
      index: "ecommerce-backend-framework-%Y-%m-%d"

  es_hibernate:
    type: elasticsearch
    inputs: [route_by_dataset.to_hibernate]
    endpoints: ["https://192.168.157.10:9200"]
    auth:
      strategy: basic
      user: elastic
      password: "KHFDPeU6"
    tls:
      ca_file: "/etc/vector/certs/http_ca.crt"
    bulk:
      index: "ecommerce-backend-hibernate-%Y-%m-%d"

  es_misc:
    type: elasticsearch
    inputs: [route_by_dataset.to_misc]
    endpoints: ["https://192.168.157.10:9200"]
    auth:
      strategy: basic
      user: elastic
      password: "KHFDPeU6"
    tls:
      ca_file: "/etc/vector/certs/http_ca.crt"
    bulk:
      index: "ecommerce-backend-misc-%Y-%m-%d"

  blackhole_unmatched:
    type: blackhole
    inputs: [route_by_dataset._unmatched]

  stdout_debug:
    type: console
    inputs:
      - route_by_dataset.to_app
      - route_by_dataset.to_framework
      - route_by_dataset.to_hibernate
      - route_by_dataset.to_misc
    target: stdout
    encoding:
      codec: json
